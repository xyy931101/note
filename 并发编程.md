# 并发编程

## volatile关键字

volatile要理解volatile首先要理解内间的8大交互操作

1.lock（主内存，将一个变量标识为线程独占）

2.unlock（主内存，释放一个处于锁状态的变量）

3.read（主内存，将变量从主内存传输到工作内存）

4.load（工作内存，将read的值在工作内存中生成一个副本）

5.use（工作内存，将工作内存中的变量传输给执行引擎）

6.assign（工作内存，将执行引擎中返回的值赋值给工作内存中的变量）

7.store（工作内存，将工作内存中的变量传输给主内存）

8.write（主内存，将store操作从工作内存中传输的值写入主内存的变量中）

以上8个操作需要成对出现，用volatile关键字修饰的变量,在工作内存中值被修改后,会调用store-write的操作，将值回写到主内存中，当下次另外一个线程reload的时候，会改写其线程内执行引擎中的变量的值

![image-20210110153742754](C:\Users\xiongyy\Desktop\技术资料\image-20210110153742754.png)

volatile3个特性

- **可见性** 

  当多个线程访问同一个共享变量时，一个线程修改了这个变量的值，其他线程能够立即看到修改后的值。

  其中原理是基于缓存一致性的原理，当有个线程修改其值时候，基于CPU原子操作、总线嗅探机制、MESI缓存一致性协议以及一点点汇编指令，来解释为什么volatile能够保证数据一致性。

- **有序性**

  ​    **禁止指令重排序**

- **不保证其原子性**



```
volatile 很适合只有一个线程修改，其他线程读取的情况。volatile 变量被修改之后，对其他线程立即可见。
```

其中volatile在懒汉式单例模式中会用到

```java
public class Full {

    /**
     * 使用volatile关键字
     * 1.禁止指令重排， 2.保证变量可见性
     */
    private volatile static  Full instance;

    /**
     * 构造方法私有化,保证单例
     */
    private Full(){}

    public static  Full getInstance(){
        //使用DCL(double check lock)
        if (instance == null){
            synchronized (Full.class){
               if (instance == null){
                   instance = new Full();
               }
            }
        }
        return instance;
    }
}

```

### 内存屏障

​	先简单了解两个指令：

- Store：将处理器缓存的数据刷新到内存中。

- Load：将内存存储的数据拷贝到处理器的缓存中。

  ![image-20210112231712774](C:\Users\xiongyy\Desktop\技术资料\图片\image-20210112231712774.png)

  ![image-20210112231933592](C:\Users\xiongyy\Desktop\技术资料\图片\image-20210112231933592.png)
  
  ![image-20210221134906634](D:\workspace\note\image\image-20210221134906634.png)

## CAS原理

CAS为Compare And Swap的简称，即：比较与交换

​	比较和替换是使用一个期望值和一个变量的当前值进行比较，如果当前变量的值与我们期望的值相等，就使用一个新值替换当前变量的值，如不相等，即再次进行比较与值得交换，直到交换成功为止。

其中底层实现是调用Unsafe的，其中本地方法调用的底层的方法是c++

```java
public final native boolean compareAndSwapInt(Object paramObject, long paramLong, int paramInt1, int paramInt2);
```

c++底层代码

```c++
inline jint Atomic::cmpxchg (jint exchange_value, volatile jint* dest, jint compare_value) {
    int mp = os::isMP(); //判断是否是多处理器
    _asm {
        mov edx, dest
        mov ecx, exchange_value
        mov eax, compare_value
        LOCK_IF_MP(mp)
        cmpxchg dword ptr [edx], ecx
    }
}
```

最终实现

​	`cmpxchg = cas修改量`

​		`lock cmpxchg`

## CAS缺点

CAS存在一个很明显的问题，即ABA问题。
 如果变量V初次读取的时候是A，并且在准备赋值的时候检查到它仍然是A，那能说明它的值没有被其他线程修改过了吗？如果在这段期间它的值曾经被改成了B，然后又改回A，那CAS操作就会误认为它从来没有被修改过。针对这种情况，java并发包中提供了一个带有标记的原子引用类"AtomicStampedReference"，它可以通过控制变量值的版本来保证CAS的正确性。





## synchronized关键字

​	synchronized的4种锁状态，级别由低到高依次为：**无锁状态**、**偏向锁状态**、**轻量级锁状态**、**重量级锁状态**

- ​	**无锁状态**   也就是对象刚创建出来,没有任何线程进行抢占
- ​    **偏向锁状态**  有线程开始抢占   对象的markword数据区记录了抢占的线程信心
- ​    **轻量级锁**      有除了锁对象头信息记录的线程之外的线程对锁进行抢占,  这时候会把偏向锁信息给撤销，然后各线程开始CAS自旋抢占锁，当CAS自旋超过10次或抢占线程数超过CPU的二分之一之后，锁会升级成重量级锁
- ​    **重量级锁状态**   需要跟OS申请资源，linux mutex,CPU从3级-0级，线程挂起，进入等待队列。

synchronized的实现过程：

1. ​	java代码 + synchronized关键字
2.  字节码:  monitorenter  -》  monitorexit
3. 在锁的执行过程中，自动升级
4. **lock comxchg**（机器指令，也就是汇编指令）

**锁在发生异常的时候是会被释放的**

```java
synchronized void say(){
        int count = 0;
        System.out.println(Thread.currentThread().getName() + "==========");
        while (true){
            count ++;
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if(count > 5){
                int i = 1/0;
                System.out.println(i);
            }
        }
    }

    synchronized void say1(){
        System.out.println(Thread.currentThread().getName() + "==============");
    }

    public static void main(String[] args) {
        SynchronizedDemo demo = new SynchronizedDemo();
        new Thread(() ->{
           demo.say();
        }, "say   say").start();

        new Thread(() ->{
           demo.say1();
        }, "say1").start();;
    }
    
```

![image-20210223231025577](D:\workspace\note\image\image-synchronizedException.png)



# Thread

## 进程

​		进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。

## 线程

​		线程是指进程内的一个执行单元,也是进程内的可调度实体。线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据

### 线程的状态

1. **新建(NEW)**：新创建了一个线程对象
2. **运行(RUNNABLE)**：Java线程中将就绪（**ready**）和运行中（**running**）两种状态笼统的成为“运行”。
   线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu 的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得cpu 时间片后变为运行中状态（running）
3. **阻塞(BLOCKED)**：阻塞状态是指线程因为某种原因放弃了cpu 使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice 转到运行(running)状态。阻塞的情况分三种： 
4. **等待(WAITING)**：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）
5. **超时等待(TIME_WAITING)**：该状态不同于WAITING，它可以在指定的时间内自行返回
6. **终止(TERMINATED)**：表示该线程已经执行完毕

![image-20210221142146403](D:\workspace\note\image\image-20210221142146403.png)



### 线程池

#### 	线程池七个参数

1. ​	**corePoolSize**    线程池核心线程大小

   线程池中会维护一个最小的线程数量，即使这些线程处理空闲状态，他们也不会被销毁，除非设置了allowCoreThreadTimeOut。这里的最小线程数量即是corePoolSize

2. **maximumPoolSize** 线程池最大线程数量

   一个任务被提交到线程池以后，首先会找有没有空闲存活线程，如果有则直接将任务交给这个空闲线程来执行，如果没有则会缓存到工作队列（后面会介绍）中，如果工作队列满了，才会创建一个新线程，然后从工作队列的头部取出一个任务交由新线程来处理，而将刚提交的任务放入工作队列尾部。线程池不会无限制的去创建新线程，它会有一个最大线程数量的限制，这个数量即由maximunPoolSize指定

3. **keepAliveTime** 空闲线程存活时间

   一个线程如果处于空闲状态，并且当前的线程数量大于corePoolSize，那么在指定时间后，这个空闲线程会被销毁，这里的指定时间由keepAliveTime来设定

4. **unit** 空闲线程存活时间单位

5. **workQueue** 工作队列

   新任务被提交后，会先进入到此工作队列中，任务调度时再从队列中取出任务。jdk中提供了四种工作队列：

   ①**ArrayBlockingQueue**

   基于数组的有界阻塞队列，按FIFO排序。新任务进来后，会放到该队列的队尾，有界的数组可以防止资源耗尽问题。当线程池中线程数量达到corePoolSize后，再有新任务进来，则会将任务放入该队列的队尾，等待被调度。如果队列已经是满的，则创建一个新线程，如果线程数量已经达到maxPoolSize，则会执行拒绝策略。

   ②**LinkedBlockingQuene**

   基于链表的无界阻塞队列（其实最大容量为Interger.MAX），按照FIFO排序。由于该队列的近似无界性，当线程池中线程数量达到corePoolSize后，再有新任务进来，会一直存入该队列，而不会去创建新线程直到maxPoolSize，因此使用该工作队列时，参数maxPoolSize其实是不起作用的。

   ③**SynchronousQuene**

   一个不缓存任务的阻塞队列，生产者放入一个任务必须等到消费者取出这个任务。也就是说新任务进来时，不会缓存，而是直接被调度执行该任务，如果没有可用线程，则创建新线程，如果线程数量达到maxPoolSize，则执行拒绝策略。

   ④**PriorityBlockingQueue**

   具有优先级的无界阻塞队列，优先级通过参数Comparator实现。

6. **threadFactory** 线程工厂

   创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程等等

7. **handler** 拒绝策略

   1. **CallerRunsPolicy**

      该策略下，在调用者线程中直接执行被拒绝任务的run方法，除非线程池已经shutdown，则直接抛弃任务

   2. **AbortPolicy**

      该策略下，直接丢弃任务，并抛出RejectedExecutionException异常

   3. **DiscardPolicy**

      该策略下，直接丢弃任务，什么都不做。

   4. **DiscardOldestPolicy**

      该策略下，抛弃进入队列最早的那个任务，然后尝试把这次拒绝的任务放入队列



#### 线程池工作流程

![image-20210221165040495](D:\workspace\note\image\image-20210221165040495.png)





# JMM（JAVA内存模型）

JAVA内存模型是通过各种操作来定义的，包括对变量的读写、监视器的加锁和释放、线程的启动合并操作。

JAVA定义了一个偏序关系称之为**Happens-Before**

1. **程序顺序规则**。 如果程序中操作A在操作B之前，那么线程中A操作将在B操作之前执行
2. **监视器锁规则**   在监视器上解锁操作必须在同一个监视器上的加锁操作之前执行
3. **volatile变量规则** 对于volatile变量的写入操作必须在对该变量的读操作之前执行
4. **线程启动规则**  在线程上对Thread.start的调用必须在改线程的任何操作之前执行
5. **线程结束规则**  在线程中的任何操作都必须在其他线程检测到该线程已经结束之前执行，或者从Thread.join中成功返回，或者在Thread.isAlive是时返回false
6. **中断规则**  当一个线程在另一个线程上调用interrupt时，必须在中断线程在检测到interrupt调用之前执行(通过抛出interruptedExceptio，或者调用isInterrupted和interrupt)
7. **终结器规则**  对象的构造函数必须在启动该对象的终结器之前执行
8. **传递性**   如果操作A在操作B之前执行，并且操作B在操作C之前执行，那么操作A必须在操作C之前执行