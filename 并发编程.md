# 并发编程

## volatile关键字

volatile要理解volatile首先要理解内间的8大交互操作

1.lock（主内存，将一个变量标识为线程独占）

2.unlock（主内存，释放一个处于锁状态的变量）

3.read（主内存，将变量从主内存传输到工作内存）

4.load（工作内存，将read的值在工作内存中生成一个副本）

5.use（工作内存，将工作内存中的变量传输给执行引擎）

6.assign（工作内存，将执行引擎中返回的值赋值给工作内存中的变量）

7.store（工作内存，将工作内存中的变量传输给主内存）

8.write（主内存，将store操作从工作内存中传输的值写入主内存的变量中）

以上8个操作需要成对出现，用volatile关键字修饰的变量,在工作内存中值被修改后,会调用store-write的操作，将值回写到主内存中，当下次另外一个线程reload的时候，会改写其线程内执行引擎中的变量的值

![image-20210110153742754](C:\Users\xiongyy\Desktop\技术资料\image-20210110153742754.png)

volatile3个特性

- **可见性** 

  当多个线程访问同一个共享变量时，一个线程修改了这个变量的值，其他线程能够立即看到修改后的值。

  其中原理是基于缓存一致性的原理，当有个线程修改其值时候，基于CPU原子操作、总线嗅探机制、MESI缓存一致性协议以及一点点汇编指令，来解释为什么volatile能够保证数据一致性。

- **有序性**

  ​    **禁止指令重排序**

- **不保证其原子性**



```
volatile 很适合只有一个线程修改，其他线程读取的情况。volatile 变量被修改之后，对其他线程立即可见。
```

其中volatile在懒汉式单例模式中会用到

```java
public class Full {

    /**
     * 使用volatile关键字
     * 1.禁止指令重排， 2.保证变量可见性
     */
    private volatile static  Full instance;

    /**
     * 构造方法私有化,保证单例
     */
    private Full(){}

    public static  Full getInstance(){
        //使用DCL(double check lock)
        if (instance == null){
            synchronized (Full.class){
               if (instance == null){
                   instance = new Full();
               }
            }
        }
        return instance;
    }
}

```

### 内存屏障

​	先简单了解两个指令：

- Store：将处理器缓存的数据刷新到内存中。

- Load：将内存存储的数据拷贝到处理器的缓存中。

  ![image-20210112231712774](C:\Users\xiongyy\Desktop\技术资料\图片\image-20210112231712774.png)

  ![image-20210112231933592](C:\Users\xiongyy\Desktop\技术资料\图片\image-20210112231933592.png)
  
  ![image-20210221134906634](D:\workspace\note\image\image-20210221134906634.png)

## CAS原理

CAS为Compare And Swap的简称，即：比较与交换

​	比较和替换是使用一个期望值和一个变量的当前值进行比较，如果当前变量的值与我们期望的值相等，就使用一个新值替换当前变量的值，如不相等，即再次进行比较与值得交换，直到交换成功为止。

其中底层实现是调用Unsafe的，其中本地方法调用的底层的方法是c++

```java
public final native boolean compareAndSwapInt(Object paramObject, long paramLong, int paramInt1, int paramInt2);
```

c++底层代码

```c++
inline jint Atomic::cmpxchg (jint exchange_value, volatile jint* dest, jint compare_value) {
    int mp = os::isMP(); //判断是否是多处理器
    _asm {
        mov edx, dest
        mov ecx, exchange_value
        mov eax, compare_value
        LOCK_IF_MP(mp)
        cmpxchg dword ptr [edx], ecx
    }
}
```

最终实现

​	`cmpxchg = cas修改量`

​		`lock cmpxchg`

## CAS缺点

CAS存在一个很明显的问题，即ABA问题。
 如果变量V初次读取的时候是A，并且在准备赋值的时候检查到它仍然是A，那能说明它的值没有被其他线程修改过了吗？如果在这段期间它的值曾经被改成了B，然后又改回A，那CAS操作就会误认为它从来没有被修改过。针对这种情况，java并发包中提供了一个带有标记的原子引用类"AtomicStampedReference"，它可以通过控制变量值的版本来保证CAS的正确性。





## synchronized关键字

​	synchronized的4种锁状态，级别由低到高依次为：**无锁状态**、**偏向锁状态**、**轻量级锁状态**、**重量级锁状态**

- ​	**无锁状态**   也就是对象刚创建出来,没有任何线程进行抢占
- ​    **偏向锁状态**  有线程开始抢占   对象的markword数据区记录了抢占的线程信心
- ​    **轻量级锁**      有除了锁对象头信息记录的线程之外的线程对锁进行抢占,  这时候会把偏向锁信息给撤销，然后各线程开始CAS自旋抢占锁，当CAS自旋超过10次或抢占线程数超过CPU的二分之一之后，锁会升级成重量级锁
- ​    **重量级锁状态**   需要跟OS申请资源，linux mutex,CPU从3级-0级，线程挂起，进入等待队列。

synchronized的实现过程：

1. ​	java代码 + synchronized关键字
2.  字节码:  monitorenter  -》  monitorexit
3. 在锁的执行过程中，自动升级
4. **lock comxchg**（机器指令，也就是汇编指令）









![image-20210113233025058](C:\Users\xiongyy\Desktop\技术资料\图片\image-20210113233025058.png)