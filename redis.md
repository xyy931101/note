# Redis的持久化

## AOF(Append Only File)日志

​	redis的日志回写顺序是：执行命令，写入内存  -》 机记录日志到磁盘

**好处**

1. 写日志时候不检查语法,在写入命令正确后，再记录日志。避免额外开销。
2. 避免对当前命令的阻塞

#### 三种回写策略

1. **Always** 命令执行完之后立即回写
2. **Everysec**  每写入一个命令之后，把日志写入到AOF文件缓冲区,然后每隔一秒把缓冲区的内容写回磁盘
3. **No** 操作系统控制的回写，只是把日志写到AOF文件缓冲区，由操作系统决定何时回写磁盘



#### 重写机制

为了避免AOF文件过大,redis有AOF文件重写机制。即：只记录当前数据库的键值的最新状态

重写过程由后台子进程bfrewriteaof执行,会fork主线程的内存记录重写日志，还会把当前主线程在重写期间的回写日志记录到重写日志的缓冲区。![6b054eb1aed0734bd81ddab9a31d0be8](D:\workspace\note\image\6b054eb1aed0734bd81ddab9a31d0be8.jpg)



# RDB(内存快照)

Redis 提供了两个命令来生成 RDB 文件，分别是 save 和 bgsave

**save**：在主线程中执行，会导致阻塞；

​	Redis 就会借助操作系统提供的写时复制技术（**Copy-On-Write, COW**），在执行快照的同时，正常处理写操作

​	子进程是由主线程 fork 生成的，可以共享主线程的所有内存数据。bgsave 子进程运行后，开始读取主线程的内存数据，并把它们写入 RDB 文件

**bgsave**：创建一个子进程，专门用于写入 RDB 文件，避免了主线程的阻塞，这也是 Redis RDB 文件生成的默认配置。



它拍的是一张内存的“大合影”，不可避免地会耗时耗力。虽然，Redis 设计了 bgsave 和写时复制方式，尽可能减少了内存快照对正常读写的影响，但是，频繁快照仍然是不太能接受的。而混合使用 RDB 和 AOF，正好可以取两者之长，避两者之短，以较小的性能开销保证数据可靠性和性能。



![4dc5fb99a1c94f70957cce1ffef419cc](D:\workspace\note\image\4dc5fb99a1c94f70957cce1ffef419cc.jpg)





# Redis高可用

## 主从同步

- 读操作：主库、从库都可以接收；

- 写操作：首先到主库执行，然后，主库将写操作同步给从库。

### 主从库同步过程

- 第一阶段是主从库间建立连接、协商同步的过程，主要是为全量复制做准备。在这一步，从库和主库建立起连接，并告诉主库即将进行同步，主库确认回复后，主从库间就可以开始同步了。
- 在第二阶段，主库将所有数据同步给从库。从库收到数据后，在本地完成数据加载。这个过程依赖于内存快照生成的 RDB 文件。
- 最后，也就是第三个阶段，主库会把第二阶段执行过程中新收到的写命令，再发送给从库。具体的操作是，当主库完成 RDB 文件发送后，就会把此时 replication buffer 中的修改操作发给从库，从库再重新执行这些操作。这样一来，主从库就实现同步了。

![redis主从过程](D:\workspace\note\image\redis主从过程.jpg)