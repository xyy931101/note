# Redis的数据类型

## String（字符串对象）

- **int** 当一个字符串是整数值得话，是以int类型保存的

- **raw** SDS (Simple Dynamic String) 简单动态字符串  保存的是字符串值，且长度大于**39**

- **embstr**  字符串长度小于39

  1. embstr创建时，内存分配次数从raw的两次降为一次
  2. 释放时，只需要调用一次内存释放函数，raw需要两次
  3. 所有数据都保存在一块，所以速度更快

  embstr实际上是只读的，当我们对embstr进行修改的时候，无论长度多少，总会变成raw



1. SDS_TYPE_5:		
2. SDS_TYPE_8:

### lsit（列表对象）

列表对象的编码可以是ziplist也可以是linkedlist.

当列表对戏满足一下条件是，对象列表使用ziplist

- 所有字符串长度小于64字节
- 列表保存的元素小于512个

### hash（哈希对象）

哈希对象可以是ziplist或者hashtable

**ziplist**：每当有新的键值对插入时，程序会把保存了键的压缩列表推入到压缩列表表尾，然后再将保存了值的压缩列表节点推入到压缩列表表位

- 保存了同一键值对的两个节点总数在一起，保存键的节点在前，保存值得节点在后。
- 先添加到哈希对象中的键值，会被放到压缩列表的表头方向而后添加的键值会被放在压缩列表的表尾

**hashtable** 使用字典作为底层实现

- 字典的每个键作为键值对的键
- 字典的值作为键值对的值

当hash对象满足一下条件时，使用ziplist编码

1. 哈希对象的所有键值对的键和值得长度都小于64字节

2. 哈希对象键值对数量小于512个。

   <!--以上条件可以通过配置文件修改-->

### set(集合对象）

集合对象的编码是intlist或hashtable

当满足一下条件时，作为intlsit保存

- 集合对象所有元素都整数
- 集合对象保存的元素不超过512个

### ZSET(有序集合)

有序集合的编码可以是ziplist和skiplist

ziplist作为有序集合时候，每个集合使用紧紧相邻的两个节点来保存，第一个节点保存元素的成员(member)，第二个节点保存节点的元素分数(source)

使用ziplsit作为有序集合的条件

- 有序集合的数量小于128个

- 有序集合所有元素成员长度都小于64

  <!--可以修改配置文件-->

### Ziplist(压缩列表)

### Skiplist(跳跃表)

​	主要用于有序集合键(**有序集合节点数>128或值的长度大于64**)，集群节点中用作内部数据结构

**实现**

# Redis的持久化

## AOF(Append Only File)日志

​	redis的日志回写顺序是：执行命令，写入内存  -》 机记录日志到磁盘

**好处**

1. 写日志时候不检查语法,在写入命令正确后，再记录日志。避免额外开销。
2. 避免对当前命令的阻塞

#### 三种回写策略

1. **Always** 命令执行完之后立即回写
2. **Everysec**  每写入一个命令之后，把日志写入到AOF文件缓冲区,然后每隔一秒把缓冲区的内容写回磁盘
3. **No** 操作系统控制的回写，只是把日志写到AOF文件缓冲区，由操作系统决定何时回写磁盘



#### 重写机制

为了避免AOF文件过大,redis有AOF文件重写机制。即：只记录当前数据库的键值的最新状态

重写过程由后台子进程bfrewriteaof执行,会fork主线程的内存记录重写日志，还会把当前主线程在重写期间的回写日志记录到重写日志的缓冲区。![6b054eb1aed0734bd81ddab9a31d0be8](D:\workspace\note\image\6b054eb1aed0734bd81ddab9a31d0be8.jpg)



# RDB(内存快照)

Redis 提供了两个命令来生成 RDB 文件，分别是 save 和 bgsave

**save**：在主线程中执行，会导致阻塞；

​	Redis 就会借助操作系统提供的写时复制技术（**Copy-On-Write, COW**），在执行快照的同时，正常处理写操作

​	子进程是由主线程 fork 生成的，可以共享主线程的所有内存数据。bgsave 子进程运行后，开始读取主线程的内存数据，并把它们写入 RDB 文件

**bgsave**：创建一个子进程，专门用于写入 RDB 文件，避免了主线程的阻塞，这也是 Redis RDB 文件生成的默认配置。



它拍的是一张内存的“大合影”，不可避免地会耗时耗力。虽然，Redis 设计了 bgsave 和写时复制方式，尽可能减少了内存快照对正常读写的影响，但是，频繁快照仍然是不太能接受的。而混合使用 RDB 和 AOF，正好可以取两者之长，避两者之短，以较小的性能开销保证数据可靠性和性能。



![4dc5fb99a1c94f70957cce1ffef419cc](D:\workspace\note\image\4dc5fb99a1c94f70957cce1ffef419cc.jpg)





# Redis高可用

## 主从同步

- 读操作：主库、从库都可以接收；

- 写操作：首先到主库执行，然后，主库将写操作同步给从库。

### 主从库同步过程

- 第一阶段是主从库间建立连接、协商同步的过程，主要是为全量复制做准备。在这一步，从库和主库建立起连接，并告诉主库即将进行同步，主库确认回复后，主从库间就可以开始同步了。
- 在第二阶段，主库将所有数据同步给从库。从库收到数据后，在本地完成数据加载。这个过程依赖于内存快照生成的 RDB 文件。
- 最后，也就是第三个阶段，主库会把第二阶段执行过程中新收到的写命令，再发送给从库。具体的操作是，当主库完成 RDB 文件发送后，就会把此时 replication buffer 中的修改操作发给从库，从库再重新执行这些操作。这样一来，主从库就实现同步了。

![redis主从过程](D:\workspace\note\image\redis主从过程.jpg)

增量复制时，主从库之间具体是怎么保持同步的呢？这里的奥妙就在于 repl_backlog_buffer 这个缓冲区。我们先来看下它是如何用于增量命令的同步的。当主从库断连后，主库会把断连期间收到的写操作命令，写入 replication buffer，同时也会把这些操作命令也写入 repl_backlog_buffer 这个缓冲区。repl_backlog_buffer 是一个环形缓冲区，主库会记录自己写到的位置，从库则会记录自己已经读到的位置。

![redis主从增量复制](D:\workspace\note\image\redis主从增量复制.jpg)





