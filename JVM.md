# JVM

### JVM类加载过程

​		类的加载过程可以分为： 加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序进行，而解析阶段则不一定，它在某些情况下可能在初始化阶段后在开始，因为java支持运行时绑定。

###### 1.**加载（loading）阶段**

​			简单的说，类加载阶段就是由类加载器负责根据一个类的全限定名来读取此类的二进制字节流到JVM内部，并存储在运行时内存区			的方法区，然后将其转换为一个与目标类型对应的java.lang.Class对象实例（Java虚拟机规范并没有明确要求一定要存储在堆区			中，只是hotspot选择将Class对戏那个存储在方法区中），这个Class对象在日后就会作为方法区中该类的各种数据的访问入口。

​	

###### 2.**链接（linking）阶段**

1）、验证
验证类数据信息是否符合JVM规范，是否是一个有效的字节码文件，验证内容涵盖了类数据信息的格式验证、语义分析、操作验证等。
格式验证：验证是否符合class文件规范
语义验证：检查一个被标记为final的类型是否包含子类；检查一个类中的final方法视频被子类进行重写；确保父类和子类之间没有不兼容的一些方法声明（比如方法签名相同，但方法的返回值不同）
操作验证：在操作数栈中的数据必须进行正确的操作，对常量池中的各种符号引用执行验证（通常在解析阶段执行，检查是否通过富豪引用中描述的全限定名定位到指定类型上，以及类成员信息的访问修饰符是否允许访问等）

2）、准备
为类中的所有静态变量分配内存空间，并为其设置一个初始值（由于还没有产生对象，实例变量不在此操作范围内）被final修饰的静态变量，会直接赋予原值；类字段的字段属性表中存在ConstantValue属性，则在准备阶段，其值就是ConstantValue的值
3）、解析
将常量池中的符号引用转为直接引用（得到类或者字段、方法在内存中的指针或者偏移量，以便直接调用该方法），这个可以在初始化之后再执行。可以认为是一些静态绑定的会被解析，动态绑定则只会在运行是进行解析；静态绑定包括一些final方法(不可以重写),static方法(只会属于当前类)，构造器(不会被重写)



###### 3.**初始化*（init）阶段**

将一个类中所有被static关键字标识的代码统一执行一遍，如果执行的是静态变量，那么就会使用用户指定的值覆盖之前在准备阶段设置的初始值；如果执行的是static代码块，那么在初始化阶段，JVM就会执行static代码块中定义的所有操作。
所有类变量初始化语句和静态代码块都会在编译时被前端编译器放在收集器里头，存放到一个特殊的方法中，这个方法就是<clinit>方法，即类/接口初始化方法。该方法的作用就是初始化一个中的变量，使用用户指定的值覆盖之前在准备阶段里设定的初始值。任何invoke之类的字节码都无法调用<clinit>方法，因为该方法只能在类加载的过程中由JVM调用。
如果父类还没有被初始化，那么优先对父类初始化，但在<clinit>方法内部不会显示调用父类的<clinit>方法，由JVM负责保证一个类的<clinit>方法执行之前，它的父类<clinit>方法已经被执行。
JVM必须确保一个类在初始化的过程中，如果是多线程需要同时初始化它，仅仅只能允许其中一个线程对其执行初始化操作，其余线程必须等待，只有在活动线程执行完对类的初始化操作之后，才会通知正在等待的其他线程。

### 类加载器：

​	用户自定义类,是由用户自定义加载器进行加载的,java的核心类库，是由引导类加载器进行加载的。

```java
public static void main(String[] args) {

        //系统类加载器
        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();
        System.out.println(systemClassLoader);

        //拓展类加载器
        ClassLoader extClassLoader = systemClassLoader.getParent();
        System.out.println(extClassLoader);

        //bootStrap(引导类加载器)加载器,最顶层,获取不到
        ClassLoader bootStrap = extClassLoader.getParent();
        System.out.println(bootStrap);

        //对于用户自定义来说,使用系统类加载器进行加载
        ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();
        System.out.println(classLoader);

        ClassLoader stringClassLoader = String.class.getClassLoader();
        System.out.println(stringClassLoader);
    }
得到结果为
sun.misc.Launcher$AppClassLoader@18b4aac2
sun.misc.Launcher$ExtClassLoader@6659c656
null
sun.misc.Launcher$AppClassLoader@18b4aac2
null
```

### 用户自定义类加载器

​	在日常开发中，用户基本上用引导类加载器、拓展类加载器，系统类加载器这3中互相配合使用的。在必要时，还可以自定义类的加载器，来定制类的加载方式。用户自定义类的加载器的时候，一般继承**URLClassLoader**，可以尽量减少用户的开发

- 隔离加载类
- 修改类的加载方式
- 拓展加载源
- 防止源代码泄露



![image-20210118232801993](C:\Users\xiongyy\Desktop\技术资料\图片\image-20210118232801993.png)



### PC寄存器（Program Counter Register）

​	PC寄存器是用来存储指向下一条指令的地址，也即将将要执行的指令代码。由执行引擎读取下一条指令。

​	1.它是一块很小的内存空间，几乎可以忽略不计。也是运行速度最快的存储区域

​	2.在jvm规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致

​	3.任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的java方法的JVM指令地	      	址；或者，如果实在执行native方法，则是未指定值（undefined）,因为程序计数器不负责本地方法栈。

​	4.它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成

​	5.字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令

​	6.它是唯一一个在java虚拟机规范中没有规定任何OOM（Out Of Memery）情况的区域,而且没有垃圾回收

### 局部变量表

栈：可以使用数组或链表来实现。

操作数栈：每个独立的栈帧中处理包含局部标量表以外还包含一个后进先出的**操作数栈**，也可以称为**表达式栈**。

​				  操作数栈，在执行方法过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈(push)/出栈(pop)。

​				  如果当前方法有返回的话，其返回值将会压入当前栈帧的操作数栈中，并更新PC寄存器中的下一条需要执行的字节码指令。

​				  其中需要注意的是，long,duble是占两个数组的位置的。

### JVM参数设置

- **堆大小设置**

​	-Xms:用来设置堆空间(新生代+老年代)的**初始**内存大小

​		-X: 是JVM的运行参数

​		ms:memory start 初始内存

​	-Xmx:用来设置堆空间(新生代+老年代)的**最大**内存大小

​		mx:memory max 最大内存

​	-XX:NewRatio 新生代与老年代比例

​	-Xmn:设置新生代空间的大小

- **默认设置**

  初始化内存大小：电脑内存大小/64

  最大内存大小：电脑内存/4

  新生代与老年代比例 默认1:2，也就是新生代占整个内存的1/3

- **手动设置**

  -Xms600m -Xmx600m -XX:NewRatio=4

  开发中建议将初始堆内存和最大内存设置成相同的值 避免频繁FullGC

- **查看参数设置**

  jps 查看进行ID jstat -gc ${pid}查看进程各个区的大小

  